#! /bin/bash

cd $(dirname "$0")
top=$PWD

find lisp -depth -name \*.elc -delete

HAVE_CHEZ_SCHEME=false
if fgrep -q '#define HAVE_CHEZ_SCHEME' src/globals.h; then
  HAVE_CHEZ_SCHEME=true
fi

export EMACSLOADPATH=$top/lisp
make -j lib lib-src
if make -j -C src temacs; then

  cd src
  # EMACS_CMD="src/emacs --batch"
  #EMACS_CMD="src/temacs --batch --load loadup"

  cd ../lisp
  # exec ddd $top/src/temacs

  EMACS_CMD=($top/src/temacs --batch --load loadup)
  
  GDB=false
  if [[ $TERM != dumb ]]; then
    GDB="gdb -x $top/src/.gdbinit -ex r --args"
  fi

  echo "${EMACS_CMD[*]}"
  #"${EMACS_CMD[@]}" ||
    $GDB "${EMACS_CMD[@]}"

  # cd lisp
  # for lisp_file in autoload.el; do
  #   EMACS_CMD=('./bootstrap-emacs' --batch --no-site-file --no-site-lisp --eval '(setq load-prefer-newer t)'  -f batch-byte-compile ../lisp/emacs-lisp/$lisp_file)
  #   echo "${EMACS_CMD[*]}"
  #   "${EMACS_CMD[@]}" || $GDB "${EMACS_CMD[@]}"
  # done
  
#   $GDB $EMACS_CMD --eval \
#     "
# (progn
#  (setq garbage-collection-messages t)
#  (message \"after-idle: %S\"
#    (prog1 (scheme-funcall 'after-idle (cons nil nil))
#    (garbage-collect))))"
  #src/emacs -Q --batch --eval "(message \"after-idle: %S\" (scheme-funcall 'after-idle))"
fi
