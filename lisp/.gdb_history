up
up
p nargs
p args
f 4
l
r
up
up
up
up
down
p offset
l
p ptr
up
l
p &dummy_lisp_var 
p &readcharfun 
p &readcharfun - &dummy_lisp_var
r
c
r
bt
f 4
p i
l
p offset
down
p shift_count
p orig_pop_count 
p bit_to_set 
up
p i
l
up
down
b record_lisp_locals 
r
n
p offset
n
p any_bits_set 
r
until 1326
p any_bits_set 
n
p fi->bit_mask[i]
n
n
n
p any_bits_set
n
p any_bits_set 
r
c
up
up
up
p shift
p fi->bit_mask
p /x fi->bit_mask
b shift_and_set 
r
c
n
p orig_pop_count 
fin
disp /x fi->bit_mask
n
n
p shift
n
n
n
p shift
r
c
b shift_left_and_set
r
c
r
c
up
up
up
up
r
c
p shift_count
p bit_to_set 
r
c
c
disp /x bytes
del 6
undisplay 6
c
r
c
up
p *fi
p shift
down
x bytes
x bytes
x bytes,+4
x/4x bytes
x/4b bytes
n
n
n
n
n
x/4b bytes
up
r
c
c
p shift_count
n
x/4b bytes
n
r
c
del 18 20
c
up
up
up
up
down
p i
b lread.c:4566
ignore 21 7
r
p i
c
p i
s
s
n
n
n
n
n
n
n
n
n
l
s
r
l
r
r
del 21
c
r
up
up
up
up
p fi
p *fi
up
l
q
p LISP_LOCAL_OFFSET_BYTES
p pop_count (bytes, LISP_LOCAL_OFFSET_BYTES
p pop_count (bytes, LISP_LOCAL_OFFSET_BYTES)
up
p pop_count (bytes, LISP_LOCAL_OFFSET_BYTES)
r
bt
f 1
p i
p 
num_arrays
p num_arrays
p array_size
p array_ptr
up
p walk_lisp_stack_callback 
down
p f
r
bt
c
bt
c
bt
down
l
c
r
r
up
p ptr
up
p base
r
up
up
bt
f 3
down
l
r
bt
up
up
info->type
p info->type
p info->ref
r
b record_scheme_ref if ptr == 0x6e112e
b record_scheme_ref if ptr == (void*)0x6e112e
b record_scheme_ref
cond 4 ptr == 0x6e112e
cond 4 ref == 0x6e112e
cond 4 ref.ptr == 0x6e112e
r
bt
r
up
p info->ref
p may_be_valid (info->ref)
up
down
l
cond 4 ref.ptr == 0x36
r
up
down
p info->ref
r

b analyze_scheme_ref if ref.ptr == 0x36
r
i b
del 4 5
b gdb_found_ref
r
up
down
p fi
p *fi
p j
p k
p array_ptr[0]
p array_ptr[2]
p array_ptr[3]
r
q
q
